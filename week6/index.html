<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <script src="https://unpkg.com/ml5@0.3.1/dist/ml5.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <title>Video clipping</title>
</head>

<body>
    <canvas id="canvas" width="640" height="480" style=''></canvas>
    <!-- <img width='640' id='imageElement' src="test-portrait2.jpg" alt="">
    <svg width='640' height='480' viewbox='0 0 640 480'>
        <defs>
            <mask id='mask'>
                <image width='640' height='480' xlink:href='mask.png' />
            </mask>
        </defs>
        <image mask='url(#mask)' width='640' height='480' xlink:href='unmasked.jpg'>
    </svg> -->
    <canvas id='others' width="640" height="480" style=''></canvas>
    <video id="webcam" width="640" height="480" autoplay style="display:none"></video>
</body>
<style>
    #others {
        background-color: white;
    }
</style>
<script>
    let socket = io.connect();
    socket.on('connect', function () {
        console.log("Connected");
    });
    // Grab elements, create settings, etc.
    let webcam = document.getElementById('webcam');
    let canvas = document.getElementById('canvas');
    let others = document.getElementById('others');
    let ctx = canvas.getContext('2d');

    //body pix - js version
    let poses = [];

    window.addEventListener('load', function () {
        navigator.mediaDevices.getUserMedia({
                video: true,
                width: 640,
                height: 480
            })
            .then(function (stream) {
                webcam.srcObject = stream;
                webcam.play();

                // setTimeout(
                //     function () {
                //         //take photos of face parts
                //         if ()
                //             ctx.drawImage(webcam, 0, 0);
                //         let snapshot = canvas.toDataURL('image/jpeg');
                //         var mypeerData = {
                //             img: snapshot
                //         };
                //     }, 1000);
            })
            .catch(function (err) {
                console.log(err);
            })
    })

    drawCameraIntoCanvas();

    function drawCameraIntoCanvas() {
        ctx.drawImage(others, 0, 0, 640, 480);
        drawMyKeypoints();
        //draw from socket
        socket.on('otherPoses', data => {
            drawOthersKeypoints(data);
            console.log(data);
        })
        // drawSkeleton();
        // window.requestAnimationFrame(drawCameraIntoCanvas);
    }
    setInterval(function () {
        drawCameraIntoCanvas()
    }, 3000);

    const poseNet = ml5.poseNet(webcam, posenetModelReady);
    poseNet.on('pose', gotPoses);

    function gotPoses(results) {
        poses = results;
        // console.log(results);
    }

    function posenetModelReady() {
        console.log("posenet model ready")
    }

    function drawOthersKeypoints(data) {
        console.log("other is drawing: " + data.part);
        ctx.clearRect(0, 0, 640, 480);
        let otherPoint = data;
        ctx.beginPath();
        ctx.arc(data.position.x, data.position.y, 10, 0, 2 * Math.PI);
        ctx.strokeStyle = "green";
        ctx.stroke();
        ctx.font = "20px Arial";
        ctx.fillText(data.part, data.position.x + 15, data.position.y + 5);
    }


    let randomParts = Math.round(Math.random() * Math.floor(4));
    console.log('bodypart: ' + randomParts);
    let thisPoint;
    //draw from own cam
    function drawMyKeypoints() {
        for (let i = 0; i < poses.length; i++) {
            thisPoint = poses[i].pose.keypoints[randomParts];
            for (let j = 0; j < poses[i].pose.keypoints.length; j++) {

                console.log(thisPoint.part);
                if (thisPoint.score > 0.8) {
                    ctx.clearRect(0, 0, 640, 480);
                    ctx.beginPath();
                    ctx.strokeStyle = "red";
                    ctx.arc(thisPoint.position.x, thisPoint.position.y, 10, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.font = "14px Arial";
                    ctx.fillText(thisPoint.part, thisPoint.position.x + 15, thisPoint.position.y + 5);
                }
            }
            socket.emit('sendPoses', thisPoint);
            // console.log(thisPoint);
        }
    }

    //draw from own cam
    // function drawSkeleton() {
    //     for (let i = 0; i < poses.length; i++) {
    //         for (let j = 0; j < poses[i].skeleton.length; j++) {
    //             let partA = poses[i].skeleton[j][0];
    //             let partB = poses[i].skeleton[j][1];
    //             ctx.beginPath();
    //             ctx.moveTo(partA.position.x, partA.position.y);
    //             ctx.lineTo(partB.position.x, partB.position.y);
    //             ctx.stroke();
    //         }
    //     }
    // }
</script>

</html>
